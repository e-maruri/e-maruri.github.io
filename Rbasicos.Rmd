---
title: "R mínimo para economistas"
output:
  html_document:
    toc: true
    toc_depth: 3
header:
  - \usepackage{amsmath}
  - \usepackage[spanish]{babel}
  - \selectlanguage{spanish}
---

```{r, echo=FALSE}
pacman::p_load(tidyverse, 
               lubridate, 
               stargazer,
               knitr,
               kableExtra,
               MASS)
```
# Básicos 
## Limpiar el espacio de trabajo
```{r}
rm(list=ls())  
```
## Tipos de datos
```{r}
c('a','b','c')  # Caracter
1:7             # Entero
40<80           # Valor logico
2+2 == 5        # Valor logico
T == TRUE       # T expresion corta de verdadero
h <- 24         # Asignar un valor a la variable h 
sum (10,20,30)    # Función suma
rep('R', times=3) # Repite la letra R el número de veces que se indica
sqrt(9)           # Raíz cuadrada de 9
```

## Vectores
```{r}
(a <- c(1,2,3,4,5,6)) 
(b <- c(1:9))
y <- c('Primaria', 'Secundaria') # Vector caracteres
1:5               # Secuencia 1-5
seq(1, 10, 0.5)   # Secuencia con incrementos diferentes a 1
y[2]              # Acceder al segundo valor del vector y
(z <- c(0, y, 5))   # Concatena escalares y vectores
```
## Matrices 
Para crear matrices con los vectores **a** y **b**: 
```{r}
(A <- matrix(a, ncol=2, byrow = TRUE))
(B <- matrix(b, ncol=3, byrow = T))
```
Para ponerle nombre a las filas y columnas de la matriz **A**
```{r}
colnames(A) <- c("X","Y")
rownames(A) <- c("A","B","C")
A
```
### Transpuesta
```{r}
t(A)
```

### Inversa
```{r}
solve(B^2) #Elevamos B al cuadrado porque sino no era invertible
```
### Multiplicación 
Con el comando %*%.
```{r}
B%*%A
```
### Seleccionar elementos de una matriz
Usando [,] justo después de la matriz, donde el primer elemento indica el número de fila y el segundo el número de columna. Si, por ejemplo, el segundo elemento se deja en blanco, R tomará todas las columnas.
```{r}
B[1,2]
B[1:2,]
```
### Combinar elementos entre matrices 
Se usa el comando *cbind* para unir columnas, y *rbind* para unir filas. Nótese que los argumentos deben tener la misma cantidad de renglones en el caso de *cbind*, y la misma cantidad de columnas en el caso de *rbind*. 
```{r}
cbind(A,B)
rbind(A,B[,1:2])
```
# Importar bases de datos
## INEGI - BIE
Una de las fuentes más comunes para descargar datos en México es el Banco de Información Económica ([BIE](https://www.inegi.org.mx/sistemas/bie/)) del INEGI. Básicamente todos los tipos de archivos de datos se leen de la misma forma, con ligeras variantes entre unos y otros, así que si dominas una forma será fácil leer otros tipos de archivos. 

Para poner un ejemplo descargamos datos de 2005 a 2019 de inflación y desempleo en formato csv. Todas las bases descargadas de ahí tienen la misma estructura, la primera fila tiene el tipo de periodicidad, en este caso mensual, y la segunda fila el nombre de las variables, que es la ruta mediante la cual se obtuvo, lo cual no es útil para procesar los datos. 

Utilizamos la función *read.csv* para leer el archivo, el primer argumento contiene la ruta del archivo, usamos la opción *skip* para saltarnos las primeras dos filas del archivo, lo que combinamos con la opción *header = FALSE* para indicar que la primera fila del archivo no contiene los nombres de las variables, los cuales hemos determinado nosotros con la opción *col.names*. También hay que tener en cuenta que las bases descargadas del BIE suelen tener notas al final de los datos, si no las consideramos la base no se cargará de manera adecuada, lo cual podemos solucionar simplemente indicando el número máximo de renglones que queremos que lea, en este caso nuestro último renglón con datos es el 182, menos dos que quitamos al inicio, 180, lo cual indicamos con la opción *nrows*.

```{r}
baseCP <- read.csv("https://raw.githubusercontent.com/e-maruri/e-maruri.github.io/master/Bases/BIE_Des_Inf_2005-2019.csv", 
                    header = F,
                    skip = 2, 
                    nrows = 180,
                    col.names = c("Periodo", "Desempleo", "Inflacion", "Indice_inf"))
# La función str nos dice la estructura de las variables en nuestro data frame
str(baseCP)
```

Nótese que la variable Periodo no está en formato fecha, lo cual es un problema al momento de procesar la información, así que ahora veremos cómo convertirla al formato adecuado. Utilizaremos la libreria *lubridate* (que tienes que instalar previamente). Esta libreria tiene varias funciones cuya idea básica es indicarle en qué forma está escrita la fecha y el programa se encarga de convertirlo al formato adecuado. Para ver las funciones para otros formatos de fecha consulta la información de *lubridate*. 

En este caso nuestra fecha tiene la forma de "y/m", es decir primero se indica el año y luego el mes, por lo que utilizaremos la función *ymd()*, añadiendo la opción *truncated=2* para indicarle que los dos últimos dígitos de la fecha, que corresponden al día, no aparecen en el nuestro formato. 

```{r}
#library(lubridate)
baseCP$Periodo <- ymd(baseCP$Periodo, truncated = 2)
str(baseCP)
```
Ahora la variable periodo está en formato fecha y podremos trabajar con ella cómodamente, como se verá más adelante, en particular en la sección de gráficas. 

## Banxico - SIE
Otra fuente de datos importante es el Sistema de Información Económica ([SIE](https://www.banxico.org.mx/SieInternet/)) de Banxico. Dejo aquí cómo cargar bases de datos de ahí porque estas tienen ciertas particularidades. 

Descargamos datos mensuales del indice de precios y cotizaciones (IPC), la tasa de interés sobre Cetes a 28 días y la tasa de interés sobre Udibonos a 10 años, esta última para mostrar qué ocurre cuando el periodo para el que descargamos los datos difiere entre series. Los datos faltantes en la base en las bases del SIE se representan con *N/E*, lo cual le tenemos que indicar a la función *read.csv* para que los lea de manera correcta, esto se hace con la opción *na.strings* como se muestra a continuación. 

```{r}
banxico <- read.csv("https://raw.githubusercontent.com/e-maruri/e-maruri.github.io/master/Bases/SIE_IPC_Cetes28_1990-2019.csv", 
                    header = F,
                    skip = 18, 
                    col.names = c("Periodo", "IPC", "Cetes28", "Udibonos10"), 
                    na.strings = "N/E")
str(banxico)
```

Nótese que una vez más la variable *Periodo* no está en formato fecha, así que la convertimos como hicimos antes. En este caso la fecha tiene el formato "d/m/y", es decir, primero el día, luego el mes y al final el año, por lo que ahora usamos la función *dmy()* de *lubridate*.

```{r}
banxico$Periodo <- dmy(banxico$Periodo)
str(banxico)
```

## Agregación de datos
También es un problema común que tienes tus datos en forma mensual pero los necesitas de manera trimestral o anual, lo cual se puede hacer fácilmente en R. Primero convertimos nuestra variable de interés en un objeto de series de tiempo de R, *ts*, y luego utilizamos la función *aggregate* como se muestra a continuación. En este caso usamos como método de agregación el promedio simple (*mean*), aunque se puede utilizar cualquier función que se desee con la opción *FUN=*.

```{r}
#Convertir la serie a un objeto ts
IPC_men <- ts(banxico$IPC, start = 1990, frequency = 12)

#Utilizamos la función aggregate para convertirlo a otra unidad de tiempo
#Trimestral
IPC_trim <- aggregate(IPC_men, nfrequency = 4, mean)

#Anual
IPC_anual <- aggregate(IPC_men, nfrequency = 1, mean)
```

## Tasas de crecimiento 
Otro problema común es calcular tasas de crecimiento, esto lo hacemos fácilmente con un *mutate* y la función *lag()* de la libreria *dplyr*. A continuación un ejemplo con los índices de precios. Primero calculamos la inflación mensual, es decir la variación porcentual del índice de precios de un mes a otro, y luego la inflación anual, i.e. la variación porcentual del índice de precios de un mes a respecto al mismo mes del año pasado, esto se hace añadiendo la opción *n=* para indicarle cuántos periodos atrás considerar el rezago. 

```{r}
baseCP <- baseCP %>% mutate(inf_mensual = ((Indice_inf/lag(Indice_inf))-1)*100,
                            inf_anual = ((Indice_inf/lag(Indice_inf, n=12))-1)*100)
head(baseCP[,-2], n=20)
```


# Tablas
Hay muchos paquetes para hacer tablas como *kable*, *kableExtra* y *stargazer*.

## Kable
Casi todo salio de [aquí](https://bookdown.org/yihui/rmarkdown-cookbook/kable.html). Para usar kable debes instalar primero la libreria *knitr*. Ahora un ejemplo con nuestra matriz **A**. 
```{r}
kable(A, 
      caption = "Primera matriz creada en forma de tabla",
      digits = 0, #para ponerle la cantidad de números después del punto
      col.names = c("$X_i$","$Y_i$")
      )
```

En *kable* no se pueden cambiar los nombres a los renglones de una matriz, se tienen que poner previamente con el comando visto en la sección anterior. Además, para poner fórmulas o caracteres especiales se necesita una sintaxis específica, como se muestra a continuación. 
```{r}
rownames(B) <- c("$\\alpha$","$\\beta$","$\\gamma$")
kable(B, col.names = c("$\\eta$","$\\delta$","$\\iota$"))
```

Hacer presentable una tabla como la de la sección pasada resulta muy sencillo, sólo tenemos que modificar una de las opciones por default de kable para que aparerzcan en blanco los NA.
```{r}
#Para que aparerzcan en blanco los NA's.
options(knitr.kable.NA = "")

kable(head(baseCP[,-2], n=20),
      digits = 2,
      col.names = c("Periodo", "Inflación", "IPC", "Inflación anual (cálculo propio)", "Inflación mensual"))
```

## kableExtra

La librería *kableExtra* (que debes instalar previamente) nos permite perzonalizar aún más las tablas de kable para que se vean más bonitas y añadir otras cosas como pie de página. Consulta [este sitio](https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html) para que veas ejemplos de lo que se puede hacer. 

Las cosas de kable se agregan con "pipes", %>%. Simplemente añadiendo *kable_styling()* hace que se vea más bonita, pero puedes agregar otras opciones como colores, niveles, etc. El pie de página se pone con la opción *footnote*, por default lo pone en dos niveles, lo que aparece después de *general_title* aparece el primer renglón y lo de *general* sale en el segundo, pero como prefiero que salga todo sólo en un renglón lo pongo como se ve enseguida. 

```{r}
kable(head(baseCP[,-2], n=20),
      digits = 2,
      col.names = c("Periodo", "Inflación", "IPC", 
                    "Inflación anual (cálculo propio)", "Inflación mensual")) %>%
  kable_styling(full_width = F, bootstrap_options = "striped") %>%
  footnote(general_title = "Fuente: elaboracion propia con datos de INEGI.", general = "")
```

También podemos agrupar filas y columnas para que se vea más bonita. Para las columnas usamos la función *add_header_above* indicando dentro de un vector el nombre y para cuántas columnas se utilizará ese grupo. Para las filas usamos la función *pack_rows*, con la opción *index* y el la misma idea que para las columnas. 

```{r}
kable(head(baseCP[,-2], n=20),
      digits = 2,
      col.names = c("Periodo", "Inflación", "IPC", 
                    "Inflación anual", "Inflación mensual")) %>%
  kable_styling(full_width = F, bootstrap_options = "striped") %>%
  footnote(general_title = "Fuente: elaboracion propia con datos de INEGI.", general = "") %>%
  add_header_above(c(" " = 1, "INEGI" = 2, "Cálculo propio" = 2)) %>%
  pack_rows(index = c("2005" = 12, "2006" = 8))
```

Para más glamour, el formato html nos permite presentar toda la tabla sin comer demasiado espacio, como muestro a continuación: 
```{r}
kable(baseCP[,-2],
      digits = 2,
      col.names = c("Periodo", "Inflación", "IPC", 
                    "Inflación anual", "Inflación mensual")) %>%
  kable_styling(full_width = T, bootstrap_options = "striped") %>%
  footnote(general_title = "Fuente: elaboracion propia con datos de INEGI.", general = "") %>%
  add_header_above(c(" " = 1, "INEGI" = 2, "Cálculo propio" = 2)) %>%
  scroll_box(width = "800px", height = "300px")
```



Si quieres tus tablas para formato latex sólo tienes que añadir la opción *format="latex"* después dentro del comando de kable, o más fácil añadir desde el inicio del documento la opción *options(knitr.table.format = "html")* y todas las tablas saldrán en formato latex. Aunque las opciones son parecidas, te recomiendo que uses simplemente la opción *booktabs=T*, tú sabrás si te convence o no. 


# Econometría 
Primero creamos una muestra aleatoria i.i.d:
$$
\begin{Bmatrix} \begin{pmatrix}  Y_i \\ X_{1i}\\ X_{2i} \end{pmatrix} \end{Bmatrix}_{i=1}^{400} \sim N_3 \begin{bmatrix} \begin{pmatrix}  1 \\ 0\\ 2 \end{pmatrix}, \begin{pmatrix}  0.8 & 0.4 & -0.2 \\ 0.4 & 1.0 & -0.8 \\ -0.2 & -0.8 & 2.0 \end{pmatrix}  \end{bmatrix}.
$$ 
```{r}
#Para los parámetros
mu <- c(100,0,2)
sigma <- matrix(c(0.8, 0.4, -0.2, 0.4, 1, -0.8, -0.2, -0.8, 2), nrow = 3, byrow = T)
#Para general la muestra 
MA <- mvrnorm(400,mu,sigma) #mvrnorm de la libreria MASS
Y <- MA[,1] 
X <- cbind(rep(1,400),MA[,2:3])
```

Sabemos que el estimador de minimos cuadrados ordinarios es $\hat b_{MCO}=(X^{\prime}X)^{-1}X^{\prime}Y$, por lo que ahora podemos calcularlo fácilmente.

```{r}
(b_mco <- solve(t(X)%*%X)%*%t(X)%*%Y)
```

## Propiedades estadísticas de los estimadores

De esta forma el modelo $Y_i=0.6+0.9X_{1i}+0.4X_{2i}+U_i$ cumple con los supuestos del modelo de regresión lineal clásico, es decir: 
\begin{enumerate}
  \item linealidad en los parámetros;
  \item observaciones provenientes de una muestra aleatoria;
  \item no colinealidad perfecta entre variables explicativas; 
  \item media condicional del término no observado igual a cero; 
  \item heterocedasticidad; y
  \item normalidad del término no observado, con media cero y varianza constante. 
\end{enumerate}


### Insesgadez
Generamos una muestra i.i.d $\begin{pmatrix} X_{1i} \\ X_{2i} \end{pmatrix}_{i=1}^{400} \sim N \begin{pmatrix} \begin{pmatrix} 13 \\ 8 \end{pmatrix}, \begin{pmatrix} 4 & 0 \\ 0 & 4.5 \end{pmatrix} \end{pmatrix}$ de variables aleatorias i.i.d.
```{r}
#Para plantar una "semilla" y se generen siempre los mismos números aleatorios
set.seed(2020)
#Para los parámetros de la muestra
mu <- c(13,8)
sigma <- matrix(c(4, 0, 0, 4.5), nrow = 2, byrow = T)
MA <- mvrnorm(400,mu,sigma)
```

Ahora generamos una muestra i.i.d. $\{U_i\}_{i=1}^{400}$ de v.a.s i.i.d donde $U_i \sim N(0,1)$, $i=1,2,...,400$ tal que $U_i$ y $\mathbf{X}_i$ son independientes $\forall i \neq j$ , $i,j \in  \{1,2,...,400\}$.
```{r}
U <- rnorm(400,mean=0,sd=1)
```

Con estos datos generamos la muestra $\{Y_i\}_{i=1}^{400}$  donde $Y_i=0.6+0.9X_{1i}+0.4X_{2i}+U_i$ , $i=1,2,...,400$.
```{r}
Y <- matrix(0, ncol=1, nrow=400)
for(i in 1:400) {
  Y[i,] <- 0.6 + 0.9*MA[i,1] + 0.6*MA[i,2] + U[i]
}
```

Ahora calculamos el estimador $\hat{b}_{MCO}=\begin{pmatrix}  \hat \beta_{0} \\ \hat \beta_{1} \\ \hat \beta_{2} \end{pmatrix}$: 
```{r}
#Primero formamos una matriz con un vector de unos al inicio para la constante 
X_1 <- cbind(rep(1,400),MA[,1],MA[,2])
#Ahora sí estimamos b_mco
b_mco <- solve(t(X_1)%*%X_1)%*%t(X_1)%*%Y
#Para presentar los resultados
rownames(b_mco) <- c("$\\beta_1$","$\\beta_2$","$\\beta_3$")
kable(b_mco, caption = "Resultados", digits = 3)
```

