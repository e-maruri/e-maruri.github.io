---
title: "R mínimo para economistas"
output:
  html_document:
    toc: true
    toc_depth: 3
header:
  - \usepackage{amsmath}
  - \usepackage[spanish]{babel}
  - \selectlanguage{spanish}
---
\renewcommand{\tablename}{Tabla} 

---
```{r, echo=FALSE}
pacman::p_load(tidyverse, 
               stargazer,
               knitr,
               MASS)
```
# Básicos 
## Limpiar el espacio de trabajo
```{r}
rm(list=ls())  
```
## Tipos de datos
```{r}
c('a','b','c')  # Caracter
1:7             # Entero
40<80           # Valor logico
2+2 == 5        # Valor logico
T == TRUE       # T expresion corta de verdadero
h <- 24         # Asignar un valor a la variable h 
sum (10,20,30)    # Función suma
rep('R', times=3) # Repite la letra R el número de veces que se indica
sqrt(9)           # Raíz cuadrada de 9
```

## Vectores
```{r}
(a <- c(1,2,3,4,5,6)) 
(b <- c(1:9))
y <- c('Primaria', 'Secundaria') # Vector caracteres
1:5               # Secuencia 1-5
seq(1, 10, 0.5)   # Secuencia con incrementos diferentes a 1
y[2]              # Acceder al segundo valor del vector y
(z <- c(0, y, 5))   # Concatena escalares y vectores
```
## Matrices 
Para crear matrices con los vectores **a** y **b**: 
```{r}
(A <- matrix(a, ncol=2, byrow = TRUE))
(B <- matrix(b, ncol=3, byrow = T))
```
Para ponerle nombre a las filas y columnas de la matriz **A**
```{r}
colnames(A) <- c("X","Y")
rownames(A) <- c("A","B","C")
A
```
### Transpuesta
```{r}
t(A)
```

### Inversa
```{r}
solve(B^2) #Elevamos B al cuadrado porque sino no era invertible
```
### Multiplicación 
Con el comando %*%.
```{r}
B%*%A
```
### Seleccionar elementos de una matriz
Usando [,] justo después de la matriz, donde el primer elemento indica el número de fila y el segundo el número de columna. Si, por ejemplo, el segundo elemento se deja en blanco, R tomará todas las columnas.
```{r}
B[1,2]
B[1:2,]
```
### Combinar elementos entre matrices 
Se usa el comando *cbind* para unir columnas, y *rbind* para unir filas. Nótese que los argumentos deben tener la misma cantidad de renglones en el caso de *cbind*, y la misma cantidad de columnas en el caso de *rbind*. 
```{r}
cbind(A,B)
rbind(A,B[,1:2])
```
# Tablas
Hay muchos paquetes para hacer tablas como *kable*, *kableExtra* y *stargazer*.

## Kable
Casi todo salio de [aquí](https://bookdown.org/yihui/rmarkdown-cookbook/kable.html). Ahora un ejemplo con nuestra matriz **A**.
```{r}
kable(A, 
      caption = "Primera matriz creada en forma de tabla",
      digits = 0, #para ponerle la cantidad de números después del punto
      col.names = c("$X_i$","$Y_i$")
      )
```

En *kable* no se pueden cambiar los nombres a los renglones de una matriz, se tienen que poner previamente con el comando visto en la sección anterior. Además, para poner fórmulas o caracteres especiales se necesita una sintaxis específica, como se muestra a continuación. 
```{r}
rownames(B) <- c("$\\alpha$","$\\beta$","$\\gamma$")
kable(B, col.names = c("$\\eta$","$\\delta$","$\\iota$"))
```


# Econometría 
Primero creamos una muestra aleatoria i.i.d:
$$
\begin{Bmatrix} \begin{pmatrix}  Y_i \\ X_{1i}\\ X_{2i} \end{pmatrix} \end{Bmatrix}_{i=1}^{400} \sim N_3 \begin{bmatrix} \begin{pmatrix}  1 \\ 0\\ 2 \end{pmatrix}, \begin{pmatrix}  0.8 & 0.4 & -0.2 \\ 0.4 & 1.0 & -0.8 \\ -0.2 & -0.8 & 2.0 \end{pmatrix}  \end{bmatrix}.
$$ 
```{r}
#Para los parámetros
mu <- c(100,0,2)
sigma <- matrix(c(0.8, 0.4, -0.2, 0.4, 1, -0.8, -0.2, -0.8, 2), nrow = 3, byrow = T)
#Para general la muestra 
MA <- mvrnorm(400,mu,sigma) #mvrnorm de la libreria MASS
Y <- MA[,1] 
X <- cbind(rep(1,400),MA[,2:3])
```

Sabemos que el estimador de minimos cuadrados ordinarios es $\hat b_{MCO}=(X^{\prime}X)^{-1}X^{\prime}Y$, por lo que ahora podemos calcularlo fácilmente.

```{r}
(b_mco <- solve(t(X)%*%X)%*%t(X)%*%Y)
```

## Propiedades estadísticas de los estimadores
### Insesgadez

Generamos una muestra i.i.d $\begin{pmatrix} X_{1i} \\ X_{2i} \end{pmatrix}_{i=1}^{400} \sim N \begin{pmatrix} \begin{pmatrix} 13 \\ 8 \end{pmatrix}, \begin{pmatrix} 4 & 0 \\ 0 & 4.5 \end{pmatrix} \end{pmatrix}$ de variables aleatorias i.i.d.
```{r}
#Para plantar una "semilla" y se generen siempre los mismos números aleatorios
set.seed(2020)
#Para los parámetros de la muestra
mu <- c(13,8)
sigma <- matrix(c(4, 0, 0, 4.5), nrow = 2, byrow = T)
MA <- mvrnorm(400,mu,sigma)
```

Ahora generamos una muestra i.i.d. $\{U_i\}_{i=1}^{400}$ de v.a.s i.i.d donde $U_i \sim N(0,1)$, $i=1,2,...,400$ tal que $U_i$ y $\mathbf{X}_i$ son independientes $\forall i \neq j$ , $i,j \in  \{1,2,...,400\}$.
```{r}
U <- rnorm(400,mean=0,sd=1)
```

Con estos datos generamos la muestra $\{Y_i\}_{i=1}^{400}$  donde $Y_i=0.6+0.9X_{1i}+0.4X_{2i}+U_i$ , $i=1,2,...,400$.
```{r}
Y <- matrix(0, ncol=1, nrow=400)
for(i in 1:400) {
  Y[i,] <- 0.6 + 0.9*MA[i,1] + 0.6*MA[i,2] + U[i]
}
```

Ahora calculamos el estimador $\hat{b}_{MCO}=\begin{pmatrix}  \hat \beta_{0} \\ \hat \beta_{1} \\ \hat \beta_{2} \end{pmatrix}$: 
```{r}
#Primero formamos una matriz con un vector de unos al inicio para la constante 
X_1 <- cbind(rep(1,400),MA[,1],MA[,2])
#Ahora sí estimamos b_mco
b_mco <- solve(t(X_1)%*%X_1)%*%t(X_1)%*%Y
#Para presentar los resultados
rownames(b_mco) <- c("$\\beta_1$","$\\beta_2$","$\\beta_3$")
kable(b_mco, caption = "Resultados", digits = 3)
```


